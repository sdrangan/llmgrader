\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{amsmath, amssymb, bm, cite, epsfig, psfrag}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{pgf,tikz}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{../styles/course}


\begin{document}

\title{Introduction to Hardware Design\\
Basic Digital Logic:  Solutions}
\author{Profs. Sundeep Rangan, Siddharth Garg}
\date{}

\maketitle

\begin{enumerate}
\item \emph{Propagation delay}:  A signal $x$ has time-value change points
\[
    (10, 0), (20, 4), (30, 2)
\]
where the time is in nanoseconds.  The signal is passed through
a circuit that produces $y = 2x+1$ with a propagation delay of \SI{3}{ns}.
What are the time-value change points of $y$?  Use $\text{x}$ for unknown values.

\begin{solution}
The change points of $y$ are:
\[
    (10,\text{x}), (13, 1), (20,\text{x}), (23, 9), (30,\text{x}), (33, 5).
\]
Note that output is unknown for \SI{3}{ns} after each input change.
\end{solution} 

\begin{gradingnotes}
The common mistake is to forget to add the unknown period.
\end{gradingnotes}

\item \emph{Critical path}: Consider the following SystemVerilog code:
\begin{systemverilogcode}
  always_ff @(posedge clk) begin
      x1 <= 3*x1>>2 - 5*x>>3 + 7;
      x2 <= 3*x1>>2 +  2;
  end
\end{systemverilogcode}
Here \texttt{3*x>>2} denotes multiplication by 3 followed by a right shift
by 2 bits (division by 4).  
Assume that:
\begin{itemize}
\item Each multiplication with shift takes \SI{4}{ns}.
\item Each addition or subtraction takes \SI{2}{ns}.
\item Registers have zero delay.
\end{itemize}
What is the critical path delay of this circuit?

\begin{solution}
  We look at the update for each register \texttt{x1} and 
  \texttt{x2} separately.
  \begin{itemize}
  \item The update for \texttt{x2} involves one multiplication and one 
  addition, so the delay is \SI{6}{ns}.
  \item The update for \texttt{x1} involves two multiplications, one subtraction,
  and one addition.  But, the two multiplications can be done in parallel.
  Thus, the delay is \SI{4}{ns} + \SI{2}{ns} + \SI{2}{ns} = \SI{8}{ns}.
  \end{itemize}
\end{solution}

\begin{gradingnotes}
The common mistake is to ignore parallelism in the 
computation of \texttt{x1}, and to add the delays of the two multiplications.
If the student incorrectly adds the two multipliers, simply point out 
that they operate in parallel and give the correct delay.  Keep 
feedback to one or two sentences.
Also, some students may immediately realize that the critical path is
through \texttt{x1} without analyzing both paths.  That is perfectly fine.
Also, a concise answer that correctly identifies the critical path and computes the correct 
delay is fully acceptable. No explanation is required.

\end{gradingnotes}

\item \emph{Sequential updates}:
Consider the following SystemVerilog code:
\begin{systemverilogcode}
  always_ff @(posedge clk) begin
      x <= x + v;
      if (x > 30) begin
          v <= -10;
      end else if (x < 0) begin
          v <= 10;
      end
  end
\end{systemverilogcode}
Starting from $(x,v)=(15,10)$, what are the values of $(x,v)$
for the next 5 clock cycles?

\begin{solution}
The first 5 clock cycles for $(x,v)$ are:
\[
  (15,10) \to (25,10) \to (35,10) \to (45,-10) \to (35,-10) \to (25,-10)
\]
\end{solution}

\begin{gradingnotes}
A common mistake is to update $v$ based on the new value of $x$
instead of the old value. In particular when $(x,v)=(25,10)$,
the next value is $(35,10)$, not $(35,-10)$. 
If this mistake is made, simply point this single error out.
Keep feedback to one or two sentences.  Also, students
may not write the initial condition, $(15,10)$. That is fine. They may also
only write four clock cycles, thinking the initial condition 
is the first cycle.  That is fine.
Other formats are also acceptable like a table or writing $x$ and $v$
separately.
No explanation is required.
\end{gradingnotes}


\item \emph{Splitting paths over multiple cycles}: Consider the following
SystemVerilog code:
\begin{systemverilogcode}
  always_comb begin
      act_in = w1*xreg+b1;
      if (act_in > 0) begin
          a = act_in;
      end else begin
          a = 0;
      end
      xsq = xreg*xreg>>4;
      y = xsq + w2*a + b2;
  end
  always_ff @(posedge clk) begin
      xreg <= x;
  end
\end{systemverilogcode} 
where \texttt{>>4} denotes a right shift by 4 bits (division by 16).
So, the code registers the input \texttt{x} into \texttt{xreg} on each clock cycle,
and produces the output \texttt{y} in a single clock cycle based on the registered value.
The circuit is to be syntheized with components:
\begin{itemize}
\item Multiplication with shift:  \SI{4}{ns}
\item Addition or subtraction:  \SI{2}{ns}
\item Logic to compute $\max\{0,u\}$:  \SI{1}{ns}
\item Registers:  zero delay
\end{itemize}
Assume that $w_1$, $b_1$, $w_2$, and $b_2$ are constants.

\begin{enumerate}[label=(\alph*)]
\item Draw a block diagram of the circuit showing an implementation of the circuit.
If this is being auto-graded, you do not need to submit the diagram.  But, I will include it in the solutions.

\item What is the critical path delay of this circuit?
\item Rewrite the code to operate over two clock cycles instead of one
to minimize the critical path delay.
What is the critical path delay of the new circuit?
\end{enumerate}

\begin{solution}
\begin{enumerate}[label=(\alph*)]

  \item See figure below.
  \item The paths are:
  \begin{itemize}
  \item \texttt{xreg} from \texttt{act\_in}:  one multiplication and one addition: \SI{6}{ns}
  \item \texttt{a = max(0, act\_in)}: \SI{1}{ns}.  Hence the total delay from \texttt{xreg} to \texttt{a} is \SI{7}{ns}.
  \item \texttt{xreg} to \texttt{xsq+b2}: one multiplication and one addition: \SI{6}{ns}, but this happens in parallel with the \texttt{a}, so does not add to the critical path.
  \item \texttt{xsq+b2} and \texttt{a} to \texttt{y = xsq + w2*a + b2}: one addition and one multiplication: \SI{6}{ns}
  \end{itemize}
    Thus, the critical path is from \texttt{xreg} to \texttt{a} to \texttt{y}, with a total delay of \SI{13}{ns}.

  \item One possible solution is below:
  \begin{systemverilogcode}
    always_comb begin
      act_in = w1*xreg+b1;
      if (act_in > 0) begin
          a = act_in;
      end else begin
          a = 0;
      end    
      y = xsq_b2 + w2*a_reg;
    end 
    always_ff @(posedge clk) begin
        xreg <= x;
        xsq_b2 <= xreg*xreg>>4 + b2;
        a_reg <= a;
    end
    \end{systemverilogcode}

    The path delays are:
    \begin{itemize}
    \item \texttt{xreg} to \texttt{a}: one multiplication, one addition, and one max operation: \SI{7}{ns}
    \item \texttt{xreg} to \texttt{xsq\_b2}: one multiplication and one addition: \SI{6}{ns}
    \item \texttt{xsq\_b2} and \texttt{a\_reg} to \texttt{y}: one multiplication and one addition: \SI{6}{ns}
    \end{itemize}
    Thus, the critical path delay is now \SI{7}{ns}.
   \end{enumerate}
   \end{solution}

\begin{gradingnotes}
Do not grade part (a) since this is a figure.

For part (b), the common mistake is failing to recognize that \texttt{a} and \texttt{xsq} can be computed in parallel.  
Some students may also forget to include the delay from \texttt{a} to \texttt{y}.  
A concise answer that correctly identifies the critical path and computes the correct delay is fully acceptable.  
No explanation is required. If they refer to the figure in part (a), that is acceptable even though the figure is not available.

For part (c), grading must follow this order:


1. Check functional correctness first:
\begin{itemize}
\item To be functionally correct, the output \texttt{y} from the student solution code in part (c)
must be identical to the output from 
part (c) of the reference solution code when both are given the same inputs \texttt{x}.
\item To test functional correctness, you must simulate the part (c) 
student code and the part (c) reference code
on a random input.  Initialize the registers to zero, take \texttt{x} to be, say 5, and some 
random values for the constants \texttt{w1}, \texttt{b1}, \texttt{w2}, and \texttt{b2}.
\item In the 'full_explanation' field of the feedback JSON,
write out the test values used for \texttt{w1}, \texttt{b1}, 
\texttt{w2}, \texttt{b2}, and \texttt{x}.
\item Simulate both codes for, say, 2 clock cycles.
\item Check the output \texttt{y} over several clock cycles for both codes.  If they match,
the design is functionally correct.
\end{itemize}
If the design is functionally incorrect, mark the result as incorrect and \emph{do not} discuss critical path delay.

2. Only if the design is functionally correct, check the critical path delay:
\begin{itemize}
\item Some solutions may be functionally correct but still have a longer critical path than necessary.
\item Examples include:
  \begin{itemize}
  \item registering \texttt{xsq} and then adding \texttt{b2} instead of registering \texttt{xsq\_b2},
  \item registering \texttt{act\_in} instead of \texttt{a},
  \item leaving \texttt{a} purely combinational while \texttt{xsq} is registered.
  \end{itemize}
\item These designs are functionally correct but do not minimize the critical path delay as required.
\end{itemize}

If a solution is functionally correct but does not minimize the critical path delay,  
give feedback that the design is functionally correct but the critical path is longer than necessary,  
and do \textbf{not} mark it as correct overall.

\end{gradingnotes}



\item \emph{Exponent}
Suppose we wish to implement the function
\[\
    y = x^i, 
\]
with an integer exponent $i \in \{0,1,2,3\}$.
The input $x$ and output $y$ are signed short integers
-- do not worry about overflow.
Write a SystemVerilog module that computes $y$.
The output should always be 2 cycles after the input, 
even if $i=0,1$ or $2$.  Use only one multiplication in 
each clock cycle.  

Hint:  You will need to use delay lines to store
the input $x$ and exponent $i$.

\begin{solution}  One possible solution is below.
\begin{systemverilogcode}
module exponent  (
    input logic clk,
    input logic shortint x,
    input logic int i,
    output logic shortint y
);

    logic shortint x_reg;
    logic shortint x2;
    logic int ireg, ireg1;

    
    always_ff @(posedge clk) begin
        // Delay line for the exponent
        ireg <= i;
        idly <= ireg;

        // Delay line for the input x and its square
        x_reg <= x;
        xsq_dly <= xreg * xreg;
        x_dly <= xreg;
    end

    always_comb begin
        // Select the correct output based on the delayed exponent
        if (idly==0) begin
            y = 1;
        end else if (idly==1) begin
            y = x_dly; // pass through for i=1
        end else if (idly==2) begin
            y = xsq_dly; // pass through for i=2
        end else begin
            y = xsq_dly * x_dly; // compute x^3
        end
    end
    
  endmodule
\end{systemverilogcode}
\end{solution}
\begin{gradingnotes}
\begin{itemize}
\item  Students often forget to delay the inputs x and i so that all signals align at the output.
\item  Students may compute $x^2$ or $x^3$ in the wrong cycle.
\item  Students may violate the “one multiply per cycle” constraint.
\item  Students may use the wrong version of $i$ (current vs delayed).
\item  Students may produce an output that is not exactly 2 cycles after the input.
\end{itemize}
\end{gradingnotes}

\item Question 2.  

\end{enumerate}

  \end{document}

